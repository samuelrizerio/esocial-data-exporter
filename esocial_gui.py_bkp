#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Interface gr√°fica para o processador de eSocial XML
Permite processamento de arquivos XML eSocial com interface amig√°vel
"""

import os
import sys
import io
import datetime
import threading
import tkinter as tk
from tkinter import filedialog, ttk, messagebox, scrolledtext
import shutil
import logging
import subprocess
from pathlib import Path
import queue

# Importa√ß√£o de m√≥dulos do eSocial quando executando como app
try:
    # Tenta usar o sistema de log aprimorado se dispon√≠vel
    from src.utils.logger_config import configurar_logger
    LOGGER_AVANCADO_DISPONIVEL = True
except ImportError:
    LOGGER_AVANCADO_DISPONIVEL = False

# Determina o diret√≥rio base da aplica√ß√£o
if getattr(sys, 'frozen', False):
    # Executando como execut√°vel compilado
    BASE_DIR = Path(os.path.dirname(sys.executable))
else:
    # Executando como script
    BASE_DIR = Path(os.path.dirname(os.path.abspath(__file__)))

# Configura√ß√£o moderna usando o ConfiguradorPath centralizado
sys.path.insert(0, str(BASE_DIR / "src"))

# Usar configurador centralizado quando dispon√≠vel
try:
    from src.utils.configurador_path import ConfiguradorPath
    configurador = ConfiguradorPath(BASE_DIR)
    configurador.configurar_paths_basicos()
    print(f"‚úÖ ConfiguradorPath ativado - Projeto: {configurador.obter_diretorio_raiz()}")
except ImportError:
    # Fallback para compatibilidade
    sys.path.insert(0, str(BASE_DIR))
    print("‚ö†Ô∏è  Usando configura√ß√£o de paths tradicional")

# Configura√ß√£o de caminhos padr√£o relativos ao execut√°vel ou script
DEFAULT_PATHS = {
    'INPUT_DIR': BASE_DIR / 'data' / 'input',
    'OUTPUT_DIR': BASE_DIR / 'data' / 'output',
    'TEMPLATES_DIR': BASE_DIR / 'data' / 'templates',
    'DATABASE_DIR': BASE_DIR / 'data' / 'db',
    'LOG_DIR': BASE_DIR / 'logs'
}

# Criar diret√≥rios padr√£o se n√£o existirem
for path in DEFAULT_PATHS.values():
    path.mkdir(parents=True, exist_ok=True)

# Configura√ß√£o do arquivo de log
log_file = DEFAULT_PATHS['LOG_DIR'] / f"esocial_gui_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.log"

# N√≠veis de log
LOG_LEVELS = {
    "DEBUG": 10,
    "INFO": 20,
    "WARNING": 30,
    "ERROR": 40
}

# Classe para redirecionar sa√≠das para widget Text e arquivo de log
class RedirecionadorTextoSimples(io.TextIOBase):
    """Redirecionador simplificado que mostra mensagens amig√°veis para o usu√°rio"""
    
    def __init__(self, text_widget, log_file=None):
        self.text_widget = text_widget
        self.log_file = log_file
        self.queue = queue.Queue()
        self.updating = False
        
    def _simplificar_mensagem(self, mensagem):
        """Converte mensagens t√©cnicas em mensagens amig√°veis para o usu√°rio"""
        if not mensagem or not isinstance(mensagem, str):
            return None
            
        lower_msg = mensagem.lower().strip()
        
        # Ignorar mensagens muito t√©cnicas ou de debug
        if any(termo in lower_msg for termo in ['debug', 'traceback', 'exception', '__main__', 'line ', 'file "/', 'sqlite', 'sql', 'conn ', 'cursor']):
            return None
        
        # Mensagens de erro
        if "erro" in lower_msg or "error" in lower_msg:
            if "banco" in lower_msg or "database" in lower_msg:
                return "‚ùå Problema no banco de dados - verifique os arquivos"
            elif "arquivo" in lower_msg or "file" in lower_msg:
                return "‚ùå Problema em um arquivo - verifique se est√° correto"
            elif "xml" in lower_msg:
                return "‚ùå Problema no arquivo XML - verifique se est√° v√°lido"
            elif "permiss√£o" in lower_msg or "permission" in lower_msg:
                return "‚ùå Sem permiss√£o para acessar arquivos"
            elif "mem√≥ria" in lower_msg or "memory" in lower_msg:
                return "‚ùå Mem√≥ria insuficiente para opera√ß√£o"
            else:
                return "‚ùå Ocorreu um problema no processamento"
        
        # Mensagens de sucesso/conclus√£o
        elif any(palavra in lower_msg for palavra in ["sucesso", "conclu√≠do", "finalizado", "completado", "success", "criado com sucesso", "finalizada"]):
            return "‚úÖ Opera√ß√£o conclu√≠da com sucesso"
        
        # Mensagens de in√≠cio de opera√ß√£o
        elif any(palavra in lower_msg for palavra in ["iniciando", "processando", "carregando", "starting", "come√ßando", "inicia o"]):
            if "xml" in lower_msg:
                return "üîÑ Processando arquivos XML..."
            elif "banco" in lower_msg or "database" in lower_msg:
                return "üîÑ Preparando banco de dados..."
            elif "export" in lower_msg:
                return "üîÑ Preparando exporta√ß√£o de dados..."
            elif "template" in lower_msg or "modelo" in lower_msg:
                return "üîÑ Preparando modelos de exporta√ß√£o..."
            else:
                return "üîÑ Iniciando processamento..."
        
        # Mensagens de progresso
        elif any(palavra in lower_msg for palavra in ["inseridos", "inserindo", "registros", "records", "salvando", "dados"]):
            if "registros" in lower_msg and any(n in lower_msg for n in ["10", "20", "30", "40", "50", "100"]):
                return "üìä Salvando dados no sistema..."
            else:
                return "üìä Salvando informa√ß√µes..."
        
        # Mensagens informativas espec√≠ficas
        elif "tabela" in lower_msg and ("criada" in lower_msg or "created" in lower_msg):
            return "üìã Preparando estrutura para armazenar os dados"
        elif "arquivo" in lower_msg and ("adicionado" in lower_msg or "processado" in lower_msg):
            return "üìÑ Arquivo processado com sucesso"
        elif any(palavra in lower_msg for palavra in ["exportando", "export", "gerando", "csv"]):
            return "üì§ Gerando arquivos de exporta√ß√£o..."
        elif "conectando" in lower_msg or "connecting" in lower_msg:
            return "üîó Conectando ao sistema..."
        
        # Mensagens de progresso ou status
        elif "backup" in lower_msg or "c√≥pia" in lower_msg:
            return "üíæ Criando c√≥pia de seguran√ßa..."
        elif "verificando" in lower_msg or "validando" in lower_msg:
            return "üîç Verificando informa√ß√µes..."
        elif any(palavra in lower_msg for palavra in ["conclu√≠do", "completed", "finalizado", "pronto"]):
            return "‚úÖ Opera√ß√£o finalizada com sucesso!"
        
        # Mensagens de aviso
        elif any(palavra in lower_msg for palavra in ["aviso", "warning", "aten√ß√£o", "cuidado"]):
            return "‚ö†Ô∏è Aten√ß√£o: Verifique as informa√ß√µes"
        
        # Mensagens simples e curtas que podem ser mostradas
        elif len(mensagem.strip()) < 80 and not any(char in mensagem for char in ['[', '{', '(', '<', '>', 'File']):
            # Remove quebras de linha e espa√ßos extras
            msg_limpa = ' '.join(mensagem.split())
            if msg_limpa and len(msg_limpa) > 3:
                return f"‚ÑπÔ∏è {msg_limpa}"
        
        # Outras mensagens t√©cnicas - n√£o mostrar no GUI
        return None
        
    def write(self, string):
        """Escreve a mensagem no log e exibe vers√£o simplificada no GUI"""
        if not string or not isinstance(string, str):
            return
            
        # Sempre salvar no log completo (arquivo)
        if self.log_file:
            timestamp = datetime.datetime.now().strftime('[%Y-%m-%d %H:%M:%S] ')
            try:
                with open(self.log_file, 'a', encoding='utf-8') as log:
                    log.write(f"{timestamp}{string}")
                    if not string.endswith('\n'):
                        log.write('\n')
            except Exception as e:
                # Se falhar ao escrever no arquivo, pelo menos mostrar no console
                print(f"Erro ao escrever no log: {e}")
        
        # Simplificar mensagem para o usu√°rio
        mensagem_simples = self._simplificar_mensagem(string)
        if mensagem_simples and self.text_widget:
            try:
                self.queue.put(mensagem_simples)
                # Reagendar atualiza√ß√£o se n√£o est√° em andamento
                if not self.updating and hasattr(self.text_widget, 'after_idle'):
                    self.text_widget.after_idle(self.update_widget)
            except Exception as e:
                # Se falhar no GUI, continuar sem erro
                print(f"Erro ao atualizar GUI: {e}")
                
    def update_widget(self):
        """Atualiza o widget de texto com mensagens da fila"""
        if self.updating:
            return
            
        self.updating = True
        try:
            while True:
                try:
                    mensagem = self.queue.get_nowait()
                    self.text_widget.config(state=tk.NORMAL)
                    
                    # Determinar cor baseada no √≠cone
                    if mensagem.startswith('‚ùå'):
                        tag = "error"
                    elif mensagem.startswith('‚ö†Ô∏è'):
                        tag = "warning"
                    elif mensagem.startswith('‚úÖ'):
                        tag = "success"
                    else:
                        tag = "info"
                        
                    # Adicionar timestamp amig√°vel
                    timestamp = datetime.datetime.now().strftime('%H:%M:%S')
                    mensagem_completa = f"[{timestamp}] {mensagem}\n"
                    
                    self.text_widget.insert(tk.END, mensagem_completa, tag)
                    self.text_widget.see(tk.END)  # Rolagem autom√°tica
                    self.text_widget.config(state=tk.DISABLED)
                except queue.Empty:
                    break
        finally:
            self.updating = False
            # Reagendar se ainda h√° mensagens
            if not self.queue.empty():
                self.text_widget.after(100, self.update_widget)
        
    def flush(self):
        """Flush para compatibilidade com sys.stdout/stderr"""
        pass
        
    def isatty(self):
        """Retorna False para compatibilidade com sys.stdout/stderr"""
        return False


class EsocialMigrationGUI:
    """Interface gr√°fica para o processador de eSocial XML"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("Exportador de XMLs do eSocial")
        
        # Configura√ß√£o de tamanho din√¢mico
        self._configurar_tamanho_tela()
        
        # Configura√ß√£o do grid principal
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=0)  # Configura√ß√µes
        self.root.rowconfigure(1, weight=1)  # √Årea principal
        self.root.rowconfigure(2, weight=0)  # Barra de status

        # Controle de estado da aplica√ß√£o
        # Estados poss√≠veis: "initial", "processing", "processed", "exporting", "exported"
        self.current_state = "initial"

        # Configura√ß√µes (caminhos)
        self.config_frame = ttk.LabelFrame(self.root, text="Configura√ß√µes")
        self.config_frame.grid(row=0, column=0, sticky="new", padx=10, pady=5)
        self.setup_config_frame()
        
        # Container principal (arquivos e log)
        self.main_container = ttk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        self.main_container.grid(row=1, column=0, sticky="nsew", padx=10, pady=5)
        
        # Frame para arquivos
        self.file_frame = ttk.LabelFrame(self.main_container, text="Arquivos XML")
        self.main_container.add(self.file_frame, weight=1)
        self.setup_file_frame()
        
        # Frame para log
        self.log_frame = ttk.LabelFrame(self.main_container, text="Logs de Processamentos")
        self.main_container.add(self.log_frame, weight=2)
        self.setup_log_frame()
        
        # Barra de a√ß√µes
        self.actions_frame = ttk.Frame(self.root)
        self.actions_frame.grid(row=2, column=0, sticky="ew", padx=10, pady=5)
        self.setup_actions_frame()
        
        # Barra de status
        self.status_var = tk.StringVar(value="Pronto")
        self.status_bar = ttk.Label(self.root, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.grid(row=3, column=0, sticky="ew", padx=10, pady=2)
        
        # Inicializar vari√°veis internas
        self.processing_thread = None
        self.stop_requested = False
        
        # Carregar arquivos da pasta de entrada, se existirem
        self.carregar_arquivos_existentes()
        
        # Carregar banco de dados padr√£o, se existir
        self.carregar_banco_dados_padrao()
        
        # Finaliza√ß√£o de configura√ß√µes
        self.update_file_count()
        self.redirect_stdout()
        
        # Vincular evento de fechamento
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        # Atualizar o estado dos bot√µes conforme o estado inicial
        self.update_button_states()
        
        # Mensagem de inicializa√ß√£o
        print(f"eSocial XML Processor - Iniciado em {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Diret√≥rio base: {BASE_DIR}")
    
    def _configurar_tamanho_tela(self):
        """Configura o tamanho da tela dinamicamente baseado na resolu√ß√£o do monitor"""
        # Obt√©m a largura e altura da tela
        largura_tela = self.root.winfo_screenwidth()
        altura_tela = self.root.winfo_screenheight()
        
        # Define tamanho da janela como 80% da tela
        largura_janela = int(largura_tela * 0.8)
        altura_janela = int(altura_tela * 0.8)
        
        # Define tamanho m√≠nimo
        self.root.minsize(800, 600)
        
        # Configura o tamanho da janela
        self.root.geometry(f"{largura_janela}x{altura_janela}")
        
        # Centraliza a janela na tela
        posicao_x = (largura_tela - largura_janela) // 2
        posicao_y = (altura_tela - altura_janela) // 2
        self.root.geometry(f"+{posicao_x}+{posicao_y}")
        
        print(f"Configurando janela com tamanho: {largura_janela}x{altura_janela}")
    
    def setup_config_frame(self):
        """Configura o frame de configura√ß√µes"""
        self.config_frame.columnconfigure(1, weight=1)
        
        # Diret√≥rio de entrada
        ttk.Label(self.config_frame, text="Diret√≥rio de Entrada:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        self.input_dir_var = tk.StringVar(value=str(DEFAULT_PATHS['INPUT_DIR']))
        input_entry = ttk.Entry(self.config_frame, textvariable=self.input_dir_var)
        input_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=5, pady=5)
        self.input_select_button = ttk.Button(self.config_frame, text="Selecionar", 
                  command=lambda: self.select_directory(self.input_dir_var))
        self.input_select_button.grid(row=0, column=2, padx=5, pady=5)
        
        # Diret√≥rio de sa√≠da
        ttk.Label(self.config_frame, text="Diret√≥rio de Sa√≠da:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)
        self.output_dir_var = tk.StringVar(value=str(DEFAULT_PATHS['OUTPUT_DIR']))
        output_entry = ttk.Entry(self.config_frame, textvariable=self.output_dir_var)
        output_entry.grid(row=1, column=1, sticky=(tk.W, tk.E), padx=5, pady=5)
        self.output_select_button = ttk.Button(self.config_frame, text="Selecionar",
                  command=lambda: self.select_directory(self.output_dir_var))
        self.output_select_button.grid(row=1, column=2, padx=5, pady=5)
        
        # Diret√≥rio de templates
        ttk.Label(self.config_frame, text="Diret√≥rio de Templates:").grid(row=2, column=0, sticky=tk.W, padx=5, pady=5)
        self.templates_dir_var = tk.StringVar(value=str(DEFAULT_PATHS['TEMPLATES_DIR']))
        templates_entry = ttk.Entry(self.config_frame, textvariable=self.templates_dir_var)
        templates_entry.grid(row=2, column=1, sticky=(tk.W, tk.E), padx=5, pady=5)
        self.templates_select_button = ttk.Button(self.config_frame, text="Selecionar",
                  command=lambda: self.select_directory(self.templates_dir_var))
        self.templates_select_button.grid(row=2, column=2, padx=5, pady=5)
        
        # Mantemos a vari√°vel do banco de dados, mas n√£o exibimos na interface
        self.db_path_var = tk.StringVar(value=str(DEFAULT_PATHS['DATABASE_DIR'] / "esocial.db"))
    
    def setup_file_frame(self):
        """Configura o frame de arquivos"""
        # Configura√ß√£o do grid
        self.file_frame.rowconfigure(0, weight=1)
        self.file_frame.rowconfigure(1, weight=0)
        self.file_frame.columnconfigure(0, weight=1)
        
        # Lista de arquivos com scrollbars
        file_list_frame = ttk.Frame(self.file_frame)
        file_list_frame.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        
        file_list_frame.rowconfigure(0, weight=1)
        file_list_frame.columnconfigure(0, weight=1)
        
        self.file_list = tk.Listbox(file_list_frame, selectmode=tk.EXTENDED)
        self.file_list.grid(row=0, column=0, sticky="nsew")
        
        scrollbar_y = ttk.Scrollbar(file_list_frame, orient="vertical", command=self.file_list.yview)
        scrollbar_y.grid(row=0, column=1, sticky="ns")
        
        scrollbar_x = ttk.Scrollbar(file_list_frame, orient="horizontal", command=self.file_list.xview)
        scrollbar_x.grid(row=1, column=0, sticky="ew")
        
        self.file_list.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
        
        # Bot√µes para gerenciar arquivos
        file_buttons_frame = ttk.Frame(self.file_frame)
        file_buttons_frame.grid(row=1, column=0, sticky="ew", padx=5, pady=5)
        
        # Armazenar refer√™ncias aos bot√µes para controle posterior
        self.add_files_button = ttk.Button(file_buttons_frame, text="Adicionar Arquivos", command=self.add_files)
        self.add_files_button.pack(side=tk.LEFT, padx=2)
        
        self.add_dir_button = ttk.Button(file_buttons_frame, text="Adicionar Pasta", command=self.add_directory)
        self.add_dir_button.pack(side=tk.LEFT, padx=2)
        
        self.clear_files_button = ttk.Button(file_buttons_frame, text="Limpar Lista", command=self.clear_file_list)
        self.clear_files_button.pack(side=tk.LEFT, padx=2)
        
        self.remove_files_button = ttk.Button(file_buttons_frame, text="Remover Selecionados", command=self.remove_selected_files)
        self.remove_files_button.pack(side=tk.LEFT, padx=2)
        
        # Label de contagem
        self.file_count_var = tk.StringVar(value="0 arquivos")
        ttk.Label(file_buttons_frame, textvariable=self.file_count_var).pack(side=tk.RIGHT, padx=5)
    
    def setup_log_frame(self):
        """Configura o frame de log"""
        # Configura√ß√£o do grid
        self.log_frame.rowconfigure(0, weight=1)
        self.log_frame.columnconfigure(0, weight=1)
        
        # Widget de texto com rolagem para logs
        self.log_text = scrolledtext.ScrolledText(self.log_frame, wrap=tk.WORD, state=tk.DISABLED)
        self.log_text.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        
        # Configura√ß√£o de estilos de texto
        self.log_text.tag_configure("error", foreground="red")
        self.log_text.tag_configure("warning", foreground="orange")
        self.log_text.tag_configure("info", foreground="blue")
        self.log_text.tag_configure("success", foreground="green")
        self.log_text.tag_configure("debug", foreground="gray")
    
    def setup_actions_frame(self):
        """Configura o frame de a√ß√µes"""
        # Renomear para "Opera√ß√µes"
        self.actions_frame.configure(padding=5)
        self.actions_label = ttk.Label(self.actions_frame, text="Opera√ß√µes")
        self.actions_label.pack(side=tk.TOP, anchor=tk.W, pady=(0, 5))
        
        # Bot√µes de a√ß√£o com refer√™ncias para controle de estados
        self.process_button = ttk.Button(self.actions_frame, text="Processar XML", 
                  command=self.start_processing, style='Primary.TButton')
        self.process_button.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.export_button = ttk.Button(self.actions_frame, text="Exportar CSV",
                  command=self.start_exporting)
        self.export_button.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.view_db_button = ttk.Button(self.actions_frame, text="Ver Banco de Dados",
                  command=self.show_database_viewer)
        self.view_db_button.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.view_output_button = ttk.Button(self.actions_frame, text="Ver Pasta de Sa√≠da",
                  command=self.open_output_folder)
        self.view_output_button.pack(side=tk.LEFT, padx=5, pady=5)
        
        # Barra de progresso
        self.progress_var = tk.DoubleVar(value=0.0)
        self.progress_bar = ttk.Progressbar(self.actions_frame, variable=self.progress_var, mode="determinate")
        self.progress_bar.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
        
        # Bot√£o de ajuda
        self.help_button = ttk.Button(self.actions_frame, text="Sobre", command=self.show_help)
        self.help_button.pack(side=tk.RIGHT, padx=5, pady=5)
    
    def redirect_stdout(self):
        """Redireciona a sa√≠da padr√£o e de erro para o widget de texto"""
        sys.stdout = RedirecionadorTextoSimples(self.log_text, log_file)
        sys.stderr = RedirecionadorTextoSimples(self.log_text, log_file)
    
    def select_directory(self, var):
        """Seleciona um diret√≥rio e atualiza a vari√°vel"""
        directory = filedialog.askdirectory(initialdir=var.get())
        if directory:
            var.set(directory)
    
    def select_database(self):
        """Seleciona um arquivo de banco de dados SQLite"""
        # Gera um nome de banco com timestamp
        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        default_db_name = f"esocial_{timestamp}.db"
        default_dir = os.path.dirname(self.db_path_var.get())
        
        # Define o caminho completo padr√£o
        default_path = os.path.join(default_dir, default_db_name)
        
        db_file = filedialog.asksaveasfilename(
            initialdir=default_dir,
            initialfile=default_db_name,
            defaultextension=".db",
            filetypes=[("SQLite Database", "*.db"), ("All Files", "*.*")],
            title="Selecionar ou Criar Banco de Dados SQLite"
        )
        
        if db_file:
            self.db_path_var.set(db_file)
            print(f"Banco de dados selecionado: {db_file}")
    
    def add_files(self):
        """Adiciona arquivos XML √† lista"""
        filepaths = filedialog.askopenfilenames(
            title="Selecionar Arquivos XML",
            initialdir=self.input_dir_var.get(),
            filetypes=[("Arquivos XML", "*.xml"), ("Todos os Arquivos", "*.*")]
        )
        
        if not filepaths:
            return
        
        # Copiar arquivos para o diret√≥rio de entrada e adicionar √† lista
        for filepath in filepaths:
            filename = os.path.basename(filepath)
            # Verificar se o arquivo j√° est√° na lista
            if filename not in [self.file_list.get(i) for i in range(self.file_list.size())]:
                self.file_list.insert(tk.END, filename)
                
                # Copiar para o diret√≥rio de entrada se necess√°rio
                dest_path = Path(self.input_dir_var.get()) / filename
                if Path(filepath) != dest_path:
                    try:
                        shutil.copy2(filepath, str(dest_path))
                    except Exception as e:
                        print(f"Erro ao copiar arquivo {filename}: {e}")
        
        self.update_file_count()
    
    def add_directory(self):
        """Adiciona todos os arquivos XML de um diret√≥rio"""
        directory = filedialog.askdirectory(
            title="Selecionar Diret√≥rio com Arquivos XML",
            initialdir=self.input_dir_var.get()
        )
        
        if not directory:
            return
        
        # Encontrar todos os arquivos XML no diret√≥rio
        xml_files = [f for f in os.listdir(directory) if f.lower().endswith('.xml')]
        
        # Adicionar √† lista e copiar para o diret√≥rio de entrada
        for filename in xml_files:
            if filename not in [self.file_list.get(i) for i in range(self.file_list.size())]:
                self.file_list.insert(tk.END, filename)
                
                # Copiar para o diret√≥rio de entrada se necess√°rio
                src_path = os.path.join(directory, filename)
                dest_path = Path(self.input_dir_var.get()) / filename
                if Path(src_path) != dest_path:
                    try:
                        shutil.copy2(src_path, str(dest_path))
                    except Exception as e:
                        print(f"Erro ao copiar arquivo {filename}: {e}")
        
        self.update_file_count()
    
    def clear_file_list(self):
        """Limpa a lista de arquivos"""
        if messagebox.askyesno("Confirmar Limpeza", "Deseja limpar a lista de arquivos?"):
            self.file_list.delete(0, tk.END)
            self.update_file_count()
    
    def remove_selected_files(self):
        """Remove os arquivos selecionados da lista"""
        selected = self.file_list.curselection()
        if not selected:
            return
            
        if messagebox.askyesno("Confirmar Remo√ß√£o", "Remover os arquivos selecionados da lista?"):
            # Remover os itens de tr√°s para frente para preservar os √≠ndices
            for i in sorted(selected, reverse=True):
                self.file_list.delete(i)
            
            self.update_file_count()
    
    def update_file_count(self):
        """Atualiza o contador de arquivos"""
        count = self.file_list.size()
        self.file_count_var.set(f"{count} {'arquivo' if count == 1 else 'arquivos'}")
    
    def clear_log(self):
        """Limpa o log"""
        self.log_text.config(state=tk.NORMAL)
        self.log_text.delete(1.0, tk.END)
        self.log_text.config(state=tk.DISABLED)
    
    def show_help(self):
        """Exibe a ajuda"""
        help_text = """
        Exportador de XMLs do eSocial
        
        Este programa permite processar arquivos XML do eSocial, armazenar seus dados 
        em um banco SQLite e export√°-los para arquivos de sa√≠da conforme templates.
        
        Passos para uso:
        
        1. Configure os diret√≥rios de entrada e sa√≠da.
        2. Adicione arquivos XML para processamento.
        3. Clique em "Processar XML" para importar os dados para o banco.
        4. Clique em "Exportar CSV" para gerar os arquivos de sa√≠da conforme templates.
        5. Use "Ver Banco de Dados" para visualizar os dados importados.
        6. Use "Ver Pasta de Sa√≠da" para abrir o explorador de arquivos na pasta de sa√≠da.
        
        Dicas:
        - Os logs de processamento s√£o salvos no diret√≥rio "logs".
        - O banco de dados original √© preservado durante o processamento.
        - Backups dos arquivos de sa√≠da s√£o criados antes de cada exporta√ß√£o.
        
        Para mais informa√ß√µes, consulte a documenta√ß√£o do projeto.
        
        Silver Sistemas
        """
        
        help_window = tk.Toplevel(self.root)
        help_window.title("Ajuda")
        help_window.geometry("600x400")
        
        help_text_widget = scrolledtext.ScrolledText(help_window, wrap=tk.WORD)
        help_text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        help_text_widget.insert(tk.END, help_text)
        help_text_widget.config(state=tk.DISABLED)
    
    def start_processing(self):
        """Inicia o processamento dos arquivos XML"""
        if self.processing_thread and self.processing_thread.is_alive():
            messagebox.showwarning("Processamento em Andamento", 
                                 "J√° existe um processamento em andamento. Aguarde a conclus√£o ou interrompa.")
            return
        
        input_dir = self.input_dir_var.get()
        output_dir = self.output_dir_var.get()
        templates_dir = self.templates_dir_var.get()
        
        # Verificar se h√° arquivos para processar
        if self.file_list.size() == 0:
            messagebox.showwarning("Sem Arquivos", "Nenhum arquivo XML adicionado para processamento.")
            return
        
        # Verificar diret√≥rios
        if not os.path.isdir(input_dir):
            messagebox.showerror("Erro", f"Diret√≥rio de entrada inv√°lido: {input_dir}")
            return
            
        if not os.path.isdir(output_dir):
            messagebox.showerror("Erro", f"Diret√≥rio de sa√≠da inv√°lido: {output_dir}")
            return
            
        if not os.path.isdir(templates_dir):
            messagebox.showerror("Erro", f"Diret√≥rio de templates inv√°lido: {templates_dir}")
            return
        
        # Verificar mapeamentos completos dos templates
        try:
            from src.configuracao.configuracoes import Configuracoes
            from src.banco_dados.gerenciador_banco_dados import GerenciadorBancoDados
            from src.exportadores.exportador_templates_empresa import ExportadorTemplatesEmpresa
            
            # Inicializar configura√ß√µes para verifica√ß√£o
            configuracoes = Configuracoes()
            configuracoes.CAMINHO_BANCO = Path(self.db_path_var.get())
            configuracoes.CAMINHO_SAIDA = Path(output_dir)
            configuracoes.CAMINHO_TEMPLATES = Path(templates_dir)
            
            # Verificar mapeamentos antes de iniciar o processamento
            gerenciador_bd = GerenciadorBancoDados(configuracoes.CAMINHO_BANCO)
            exportador = ExportadorTemplatesEmpresa(gerenciador_bd, configuracoes)
            
            print("Verificando mapeamentos dos templates antes de iniciar processamento...")
            if not exportador.verificar_mapeamentos_completos():
                if not messagebox.askyesno("Mapeamentos Incompletos", 
                                         "Alguns campos dos templates n√£o est√£o mapeados. Deseja continuar mesmo assim?"):
                    return
                print("Usu√°rio optou por continuar mesmo com mapeamentos incompletos.")
            else:
                print("‚úì Todos os mapeamentos est√£o completos!")
                
        except Exception as e:
            print(f"Erro ao verificar mapeamentos: {e}")
            if not messagebox.askyesno("Erro na verifica√ß√£o", 
                                     f"Erro ao verificar mapeamentos: {str(e)}\n\nDeseja continuar mesmo assim?"):
                return
            
        # Usar o banco de dados padr√£o (esocial.db) ao inv√©s de criar um com timestamp
        db_dir = DEFAULT_PATHS['DATABASE_DIR']
        db_path = str(db_dir / "esocial.db")
        self.db_path_var.set(db_path)
        print(f"Usando banco de dados padr√£o para este processamento: {db_path}")
        
        # Criar diret√≥rio do banco de dados se n√£o existir
        os.makedirs(os.path.dirname(db_path), exist_ok=True)
        
        # Limpar arquivos anteriores (com backup)
        self.cleanup_before_processing(db_path)
        
        # Resetar flag de parada
        self.stop_requested = False
        
        # Atualizar estado da aplica√ß√£o para "processing"
        self.current_state = "processing"
        self.update_button_states()
        
        # Iniciar thread de processamento
        self.processing_thread = threading.Thread(
            target=self.run_processing,
            args=(input_dir, db_path),
            daemon=True
        )
        self.processing_thread.start()
        
        # Atualizar interface
        self.status_var.set("Processando arquivos XML...")
        self.progress_var.set(0)
    
    def start_exporting(self):
        """Inicia a exporta√ß√£o para CSV"""
        if self.processing_thread and self.processing_thread.is_alive():
            messagebox.showwarning("Processamento em Andamento", 
                                 "J√° existe um processamento em andamento. Aguarde a conclus√£o ou interrompa.")
            return
        
        db_path = self.db_path_var.get()
        output_dir = self.output_dir_var.get()
        templates_dir = self.templates_dir_var.get()
        
        # Verificar diret√≥rios
        if not os.path.isdir(output_dir):
            messagebox.showerror("Erro", f"Diret√≥rio de sa√≠da inv√°lido: {output_dir}")
            return
            
        if not os.path.isdir(templates_dir):
            messagebox.showerror("Erro", f"Diret√≥rio de templates inv√°lido: {templates_dir}")
            return
            
        if not os.path.isfile(db_path):
            messagebox.showerror("Erro", f"Banco de dados n√£o encontrado: {db_path}")
            return
        
        # Limpar arquivos de sa√≠da anteriores
        self.cleanup_before_processing(db_path, output_dir)
        
        # Resetar flag de parada
        self.stop_requested = False
        
        # Atualizar estado da aplica√ß√£o para "exporting"
        self.current_state = "exporting"
        self.update_button_states()
        
        # Iniciar thread de exporta√ß√£o
        self.processing_thread = threading.Thread(
            target=self.run_exporting,
            args=(db_path, output_dir, templates_dir),
            daemon=True
        )
        self.processing_thread.start()
        
        # Atualizar interface
        self.status_var.set("Exportando...")
        self.progress_var.set(0)
    
    def stop_processing(self):
        """Interrompe o processamento"""
        if self.processing_thread and self.processing_thread.is_alive():
            if messagebox.askyesno("Confirmar Parada", 
                                "Interromper o processamento atual? Esta opera√ß√£o pode deixar dados incompletos."):
                self.stop_requested = True
                self.status_var.set("Interrompendo processamento...")
                print("Solicita√ß√£o de interrup√ß√£o enviada. Aguardando finaliza√ß√£o...")
        else:
            messagebox.showinfo("Informa√ß√£o", "N√£o h√° processamento em andamento.")
    
    def run_processing(self, input_dir, db_path):
        """Executa o processamento de arquivos XML em uma thread separada"""
        try:
            from src.configuracao.configuracoes import Configuracoes
            from src.banco_dados.gerenciador_banco_dados import GerenciadorBancoDados
            from src.processadores.processador_xml import ProcessadorXML
            
            # Configurar logger avan√ßado para suprimir mensagens de erro repetitivas
            if LOGGER_AVANCADO_DISPONIVEL:
                # Fun√ß√£o para enviar logs para a interface gr√°fica
                def gui_output_func(msg, level):
                    # Suprimir erros excessivos para n√£o sobrecarregar a UI
                    if level >= logging.ERROR:
                        # Limitamos a exibi√ß√£o de erros na UI
                        return
                    print(msg)
                
                # Usar logger avan√ßado com filtragem de erros
                logger = configurar_logger(
                    nivel="INFO",
                    diretorio_logs=Path("logs"),
                    gui_output_func=gui_output_func,
                    filtrar_duplicados=True
                )
                logger.info(f"eSocial XML Processor - Iniciado em {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                logger.info(f"Diret√≥rio base: {BASE_DIR}")
            
            print(f"Iniciando processamento de arquivos XML em {input_dir}")
            print(f"Banco de dados: {db_path}")
            
            # Inicializar configura√ß√µes
            configuracoes = Configuracoes()
            configuracoes.CAMINHO_BANCO = Path(db_path)
            configuracoes.CAMINHO_ENTRADA = Path(input_dir)
            
            # Inicializar gerenciador de banco de dados
            gerenciador_bd = GerenciadorBancoDados(configuracoes.CAMINHO_BANCO)
            
            # Limpar dados antes de iniciar um novo processamento para evitar duplica√ß√µes
            sucesso_limpeza = gerenciador_bd.limpar_dados_para_processamento()
            if not sucesso_limpeza:
                print("‚ö†Ô∏è Aviso: Falha ao limpar dados antigos. O processamento continuar√°, mas pode haver duplica√ß√£o de registros.")
            
            # Inicializar processador XML
            processador_xml = ProcessadorXML(gerenciador_bd, configuracoes)
            
            # Obter a lista de arquivos para processar
            files = [self.file_list.get(i) for i in range(self.file_list.size())]
            total_files = len(files)
            
            for i, filename in enumerate(files):
                # Verificar se foi solicitada parada
                if self.stop_requested:
                    print("Processamento interrompido pelo usu√°rio.")
                    # Atualizar estado para inicial se interrompido
                    self.root.after(0, lambda: setattr(self, 'current_state', 'initial'))
                    self.root.after(0, self.update_button_states)
                    break
                
                filepath = os.path.join(input_dir, filename)
                print(f"Processando arquivo {i+1}/{total_files}: {filename}")
                
                try:
                    processador_xml.processar_arquivo(filepath)
                    print(f"Arquivo {filename} processado com sucesso!")
                except Exception as e:
                    print(f"Erro ao processar arquivo {filename}: {e}")
                
                # Atualizar barra de progresso
                progress = ((i + 1) / total_files) * 100
                self.progress_var.set(progress)
                
                # Atualizar status
                self.status_var.set(f"Processando: {i+1}/{total_files} ({int(progress)}%)")
                
            # Se n√£o foi solicitada parada, atualizar estado para "processed"
            if not self.stop_requested:
                print("Processamento conclu√≠do!")
                self.status_var.set("Processamento conclu√≠do!")
                # Usar after para atualizar estado de forma segura na thread principal
                self.root.after(0, lambda: setattr(self, 'current_state', 'processed'))
                self.root.after(0, self.update_button_states)
            
        except Exception as e:
            print(f"Erro durante o processamento: {e}")
            self.status_var.set(f"Erro: {str(e)[:50]}...")
            # Em caso de erro, voltar ao estado inicial
            self.root.after(0, lambda: setattr(self, 'current_state', 'initial'))
            self.root.after(0, self.update_button_states)
        finally:
            # Garantir que a barra de progresso esteja completa ou zerada
            if self.stop_requested:
                self.progress_var.set(0)
            else:
                self.progress_var.set(100)
    
    def run_exporting(self, db_path, output_dir, templates_dir):
        """Executa a exporta√ß√£o em uma thread separada"""
        try:
            from src.configuracao.configuracoes import Configuracoes
            from src.banco_dados.gerenciador_banco_dados import GerenciadorBancoDados
            from src.exportadores.exportador_templates_empresa import ExportadorTemplatesEmpresa
            
            print(f"Iniciando exporta√ß√£o em {output_dir}")
            print(f"Usando templates de {templates_dir}")
            print(f"Banco de dados: {db_path}")
            
            # Verificar se o banco de dados existe
            if not Path(db_path).exists():
                print(f"‚ö†Ô∏è Banco de dados n√£o encontrado: {db_path}")
                self.status_var.set("Erro: Banco de dados n√£o encontrado")
                # Voltar ao estado anterior em caso de erro
                self.root.after(0, lambda: setattr(self, 'current_state', 'processed'))
                self.root.after(0, self.update_button_states)
                return
            
            # Inicializar configura√ß√µes
            configuracoes = Configuracoes()
            configuracoes.CAMINHO_BANCO = Path(db_path)
            configuracoes.CAMINHO_SAIDA = Path(output_dir)
            configuracoes.CAMINHO_TEMPLATES = Path(templates_dir)
            
            # Inicializar gerenciador de banco de dados
            gerenciador_bd = GerenciadorBancoDados(configuracoes.CAMINHO_BANCO)
            
            # Verificar se h√° tabelas no banco
            tabelas = gerenciador_bd.obter_tabelas()
            print(f"Tabelas dispon√≠veis no banco: {tabelas}")
            if not tabelas:
                print(f"‚ö†Ô∏è N√£o h√° tabelas no banco de dados. Exporte n√£o ter√° dados.")
                self.status_var.set("Erro: Banco de dados vazio")
                # Voltar ao estado anterior em caso de erro
                self.root.after(0, lambda: setattr(self, 'current_state', 'processed'))
                self.root.after(0, self.update_button_states)
                return
            
            # Verificar se h√° dados nas tabelas principais
            tabelas_principais = ['esocial_s2200', 'esocial_s2205', 'esocial_s2230', 'esocial_s1200']
            for tabela in tabelas_principais:
                if tabela in tabelas:
                    count_query = f"SELECT COUNT(*) as total FROM {tabela}"
                    resultado = gerenciador_bd.executar_query(count_query)
                    if resultado and resultado[0]['total'] > 0:
                        print(f"‚úÖ Tabela {tabela}: {resultado[0]['total']} registros encontrados")
                    else:
                        print(f"‚ö†Ô∏è Tabela {tabela}: Nenhum registro encontrado")
            
            # Exportar apenas os 9 CSVs da Empresa
            print("Exportando...")
            exportador_empresa = ExportadorTemplatesEmpresa(gerenciador_bd, configuracoes)
            empresa_count = exportador_empresa.exportar_todos_templates()
            print(f"Exporta√ß√£o conclu√≠da! {empresa_count} templates processados.")
            
            # Verificar diret√≥rio de sa√≠da 
            arquivos_gerados = list(Path(output_dir).glob('**/*.csv'))
            print(f"Total de arquivos gerados: {len(arquivos_gerados)}")
            for arquivo in arquivos_gerados[:9]:  # Mostrar os 9 arquivos
                print(f"  - {arquivo.name}")
                
            # Resumo da exporta√ß√£o
            print(f"\n===== RESUMO DA EXPORTA√á√ÉO =====")
            print(f"Templates Atuais: {empresa_count}")
            print(f"Arquivos gerados: {len(arquivos_gerados)}")
            print(f"===== FIM DO RESUMO =====\n")
            
            self.status_var.set(f"Exporta√ß√£o conclu√≠da! {len(arquivos_gerados)} arquivos gerados.")
            
            # Se n√£o solicitou parada, atualizar para estado "exported"
            if not self.stop_requested:
                # Usar after para atualizar estado de forma segura na thread principal
                self.root.after(0, lambda: setattr(self, 'current_state', 'exported'))
                self.root.after(0, self.update_button_states)
            
        except Exception as e:
            print(f"Erro durante a exporta√ß√£o: {e}")
            import traceback
            traceback.print_exc()
            self.status_var.set(f"Erro: {str(e)[:50]}...")
            # Em caso de erro, voltar ao estado anterior
            self.root.after(0, lambda: setattr(self, 'current_state', 'processed'))
            self.root.after(0, self.update_button_states)
        finally:
            # Garantir que a barra de progresso esteja completa ou zerada
            if self.stop_requested:
                self.progress_var.set(0)
            else:
                self.progress_var.set(100)
    
    def show_database_viewer(self):
        """Abre janela para visualiza√ß√£o das tabelas do banco de dados"""
        import sqlite3
        
        db_path = self.db_path_var.get()
        
        # Verificar se o banco de dados existe
        if not os.path.exists(db_path):
            messagebox.showwarning("Aviso", 
                "Banco de dados n√£o encontrado. Execute um processamento primeiro.")
            print("AVISO: Banco de dados n√£o encontrado.")
            return
        
        try:
            # Conectar ao banco
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Obter lista de tabelas
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'")
            tables = [table[0] for table in cursor.fetchall()]
            
            if not tables:
                messagebox.showinfo("Informa√ß√£o", "Nenhuma tabela encontrada no banco de dados.")
                conn.close()
                return
            
            print(f"Abrindo visualizador de banco de dados com {len(tables)} tabelas")
            
            # Criar janela do visualizador
            viewer_window = tk.Toplevel(self.root)
            viewer_window.title("Visualizador de Banco de Dados - eSocial")
            viewer_window.geometry("1000x700")
            viewer_window.minsize(800, 600)
            
            # Configurar grid principal
            viewer_window.rowconfigure(0, weight=0)  # toolbar
            viewer_window.rowconfigure(1, weight=1)  # notebook
            viewer_window.rowconfigure(2, weight=0)  # status
            viewer_window.columnconfigure(0, weight=1)
            
            # Frame de ferramentas
            toolbar_frame = ttk.Frame(viewer_window)
            toolbar_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=5)
            
            ttk.Label(toolbar_frame, text="Banco de Dados:", font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=5)
            ttk.Label(toolbar_frame, text=os.path.basename(db_path)).pack(side=tk.LEFT, padx=5)
            
            # Bot√£o de atualiza√ß√£o
            ttk.Button(toolbar_frame, text="Atualizar Dados", 
                      command=lambda: self.refresh_database_viewer(notebook, tables, conn)).pack(side=tk.RIGHT, padx=5)
            
            # Notebook para as tabelas
            notebook = ttk.Notebook(viewer_window)
            notebook.grid(row=1, column=0, sticky="nsew", padx=10, pady=5)
            
            # Barra de status - ser√° atualizada pelo m√©todo create_database_tabs
            status_var = tk.StringVar(value=f"Banco de dados conectado")
            status_bar = ttk.Label(viewer_window, textvariable=status_var, relief=tk.SUNKEN, anchor=tk.W)
            status_bar.grid(row=2, column=0, sticky="ew", padx=10, pady=2)
            
            # Criar abas para cada tabela
            self.create_database_tabs(notebook, tables, conn, status_var)
            
            # Configurar fechamento da janela
            def on_viewer_close():
                try:
                    conn.close()
                    print("Conex√£o com banco de dados fechada.")
                except:
                    pass
                viewer_window.destroy()
            
            viewer_window.protocol("WM_DELETE_WINDOW", on_viewer_close)
            
            print("Visualizador de banco de dados aberto com sucesso.")
            
        except sqlite3.Error as e:
            messagebox.showerror("Erro de Banco de Dados", f"Erro ao acessar o banco: {str(e)}")
            print(f"ERRO DB: {str(e)}")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao abrir visualizador: {str(e)}")
            print(f"ERRO: {str(e)}")

    def create_database_tabs(self, notebook, tables, conn, status_var):
        """Cria abas para cada tabela do banco de dados"""
        cursor = conn.cursor()
        
        # Tabelas que devem ser exclu√≠das da visualiza√ß√£o
        tabelas_excluidas = ['esocial_s1000', 'esocial_s2299']
        tabelas_filtradas = [t for t in tables if t not in tabelas_excluidas]
        
        # Atualizar contador de tabelas na interface
        total_tabelas = len(tabelas_filtradas)
        status_var.set(f"Banco de dados conectado - {total_tabelas} tabelas exibidas")
        
        for table_name in sorted(tabelas_filtradas):
            try:
                # Obter informa√ß√µes da tabela
                cursor.execute(f"PRAGMA table_info({table_name})")
                columns_info = cursor.fetchall()
                columns = [col[1] for col in columns_info]  # Nome das colunas
                
                # Contar registros
                cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
                total_records = cursor.fetchone()[0]
                
                # Criar frame da aba
                tab_frame = ttk.Frame(notebook)
                notebook.add(tab_frame, text=f"{table_name} ({total_records})")
                
                # Configurar grid da aba
                tab_frame.rowconfigure(0, weight=1)  # tabela (removido controle de busca)
                tab_frame.columnconfigure(0, weight=1)
                
                # Frame da tabela
                table_frame = ttk.Frame(tab_frame)
                table_frame.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
                table_frame.rowconfigure(0, weight=1)
                table_frame.columnconfigure(0, weight=1)
                
                # Criar Treeview
                tree = ttk.Treeview(table_frame, columns=columns, show="headings", selectmode="browse")
                tree.grid(row=0, column=0, sticky="nsew")
                
                # Barras de rolagem
                v_scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=tree.yview)
                v_scrollbar.grid(row=0, column=1, sticky="ns")
                h_scrollbar = ttk.Scrollbar(table_frame, orient="horizontal", command=tree.xview)
                h_scrollbar.grid(row=1, column=0, sticky="ew")
                
                tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
                
                # Configurar colunas
                for col in columns:
                    tree.heading(col, text=col.upper())
                    tree.column(col, width=120, minwidth=80)
                
                # Carregar dados (limitados a 100 registros)
                self.load_table_data(tree, table_name, columns, conn, limit=100)
                
            except Exception as e:
                print(f"Erro ao configurar aba para tabela {table_name}: {e}")
    
    def load_table_data(self, tree, table_name, columns, conn, limit=100):
        """Carrega dados de uma tabela no Treeview"""
        try:
            # Limpar dados atuais
            tree.delete(*tree.get_children())
            
            # Executar consulta
            cursor = conn.cursor()
            cursor.execute(f"SELECT * FROM {table_name} LIMIT {limit}")
            rows = cursor.fetchall()
            
            # Inserir resultados
            for i, row in enumerate(rows):
                tree.insert("", tk.END, values=row)
        except Exception as e:
            print(f"Erro ao carregar dados da tabela {table_name}: {e}")

    def refresh_database_viewer(self, notebook, tables, conn):
        """Atualiza os dados do visualizador de banco"""
        try:
            # Salvar aba atual selecionada
            current_tab = notebook.index(notebook.select())
            
            # Limpar todas as abas
            for tab in notebook.tabs():
                notebook.forget(tab)
            
            # Obter lista atual de tabelas
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'")
            updated_tables = [table[0] for table in cursor.fetchall()]
            
            # Criar novas abas (as tabelas exclu√≠das ser√£o filtradas no create_database_tabs)
            status_var = tk.StringVar(value=f"Banco de dados atualizado")
            self.create_database_tabs(notebook, updated_tables, conn, status_var)
            
            # Restaurar sele√ß√£o de aba se poss√≠vel
            if len(notebook.tabs()) > current_tab:
                notebook.select(current_tab)
                
            print("Visualizador de banco de dados atualizado")
            
        except Exception as e:
            print(f"Erro ao atualizar visualizador de banco: {e}")
            messagebox.showerror("Erro", f"Erro ao atualizar visualizador: {str(e)}")
    
    def on_closing(self):
        """Confirma sa√≠da quando h√° processamento em execu√ß√£o"""
        if self.processing_thread and self.processing_thread.is_alive():
            if messagebox.askyesno("Confirmar Sa√≠da", "Um processamento est√° em execu√ß√£o. Encerrar mesmo assim?"):
                print("Encerrando aplica√ß√£o durante processamento...")
                # Marca pedido de encerramento
                self.stop_requested = True
                # Remover o arquivo esocial.db ao fechar
                self._remover_banco_dados()
                # Restaura stdout e stderr originais
                sys.stdout = sys.__stdout__
                sys.stderr = sys.__stderr__
                # Encerra a aplica√ß√£o
                self.root.destroy()
        else:
            print("Encerrando aplica√ß√£o...")
            # Remover o arquivo esocial.db ao fechar
            self._remover_banco_dados()
            # Restaura stdout e stderr originais
            sys.stdout = sys.__stdout__
            sys.stderr = sys.__stderr__
            # Encerra a aplica√ß√£o
            self.root.destroy()
    
    def _remover_banco_dados(self):
        """Remove o arquivo esocial.db ao finalizar a aplica√ß√£o"""
        try:
            db_path = DEFAULT_PATHS['DATABASE_DIR'] / "esocial.db"
            if db_path.exists():
                os.remove(db_path)
                print(f"‚úÖ Banco de dados removido: {db_path}")
        except Exception as e:
            print(f"‚ùå Erro ao remover banco de dados: {e}")

    def carregar_arquivos_existentes(self):
        """Carrega arquivos XML existentes na pasta de entrada"""
        try:
            input_dir = self.input_dir_var.get()
            if os.path.isdir(input_dir):
                # Encontrar todos os arquivos XML no diret√≥rio
                xml_files = [f for f in os.listdir(input_dir) if f.lower().endswith('.xml')]
                
                # Adicionar √† lista
                for filename in xml_files:
                    self.file_list.insert(tk.END, filename)
                
                self.update_file_count()
                
                if xml_files:
                    print(f"Carregados {len(xml_files)} arquivos XML da pasta de entrada")
        except Exception as e:
            print(f"Erro ao carregar arquivos existentes: {e}")
    
    def carregar_banco_dados_padrao(self):
        """Carrega o banco de dados padr√£o esocial.db se existir"""
        try:
            # Verificar se existe o banco de dados padr√£o
            db_path_padrao = DEFAULT_PATHS['DATABASE_DIR'] / "esocial.db"
            if db_path_padrao.exists():
                self.db_path_var.set(str(db_path_padrao))
                print(f"Banco de dados padr√£o carregado: {db_path_padrao}")
                
                # Verificar tabelas no banco
                import sqlite3
                try:
                    conn = sqlite3.connect(str(db_path_padrao))
                    cursor = conn.cursor()
                    cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'")
                    tables = [table[0] for table in cursor.fetchall()]
                    conn.close()
                    
                    if tables:
                        print(f"Banco de dados cont√©m {len(tables)} tabelas: {', '.join(tables)}")
                except sqlite3.Error as e:
                    print(f"Aviso: Banco de dados encontrado, mas n√£o foi poss√≠vel verificar as tabelas: {e}")
        except Exception as e:
            print(f"Erro ao carregar banco de dados padr√£o: {e}")
    
    def cleanup_before_processing(self, db_path, output_dir=None):
        """Limpa arquivos anteriores antes de iniciar processamento"""
        try:
            # Verificar se o banco existe
            db_path_obj = Path(db_path)
            if db_path_obj.exists():
                # N√ÉO fazer backup nem excluir o banco original para preservar os dados
                print(f"‚ÑπÔ∏è Banco de dados existente ser√° mantido para processamento")
            
            # 2. Limpar diret√≥rio de sa√≠da se especificado
            if output_dir and os.path.isdir(output_dir):
                # Verificar se diret√≥rio tem arquivos
                files = os.listdir(output_dir)
                if files:
                    # Remover arquivos do diret√≥rio de sa√≠da diretamente sem criar backup
                    for file in files:
                        file_path = Path(output_dir) / file
                        if file_path.is_file():  # S√≥ remover arquivos, n√£o diret√≥rios
                            os.remove(file_path)
                    
                    print(f"üóëÔ∏è Diret√≥rio de sa√≠da limpo para nova exporta√ß√£o")
            
            return True
        
        except Exception as e:
            print(f"‚ùå Erro durante limpeza de arquivos anteriores: {e}")
            return False
            
    def open_output_folder(self):
        """Abre a pasta de sa√≠da no explorador de arquivos"""
        output_dir = self.output_dir_var.get()
        
        if not os.path.isdir(output_dir):
            messagebox.showwarning("Aviso", 
                f"O diret√≥rio de sa√≠da n√£o existe: {output_dir}\n\nCrie o diret√≥rio ou execute uma exporta√ß√£o primeiro.")
            return
            
        try:
            # Abrir a pasta no explorador de arquivos do sistema operacional
            print(f"Abrindo pasta de sa√≠da: {output_dir}")
            
            if sys.platform == 'win32':
                os.startfile(output_dir)
            elif sys.platform == 'darwin':  # macOS
                subprocess.Popen(['open', output_dir])
            else:  # Linux e outros
                subprocess.Popen(['xdg-open', output_dir])
                
            self.status_var.set(f"Pasta de sa√≠da aberta: {output_dir}")
            
        except Exception as e:
            messagebox.showerror("Erro", f"N√£o foi poss√≠vel abrir a pasta: {str(e)}")
            print(f"Erro ao abrir pasta de sa√≠da: {e}")
            self.status_var.set("Erro ao abrir pasta de sa√≠da")
    
    def update_button_states(self):
        """Atualiza o estado dos bot√µes conforme o estado atual da aplica√ß√£o"""
        # Desabilitar todos os bot√µes de a√ß√£o primeiro
        self.process_button.config(state=tk.DISABLED, style='TButton')  # Reset para estilo normal
        self.export_button.config(state=tk.DISABLED, style='TButton')   # Reset para estilo normal
        self.view_db_button.config(state=tk.DISABLED)
        self.view_output_button.config(state=tk.DISABLED)
        self.help_button.config(state=tk.DISABLED)
        
        # Desabilitar bot√µes de gerenciamento de arquivos
        self.add_files_button.config(state=tk.DISABLED)
        self.add_dir_button.config(state=tk.DISABLED)
        self.clear_files_button.config(state=tk.DISABLED)
        self.remove_files_button.config(state=tk.DISABLED)
        
        # Desabilitar bot√µes de configura√ß√£o
        self.input_select_button.config(state=tk.DISABLED)
        self.output_select_button.config(state=tk.DISABLED)
        self.templates_select_button.config(state=tk.DISABLED)
        
        # Habilitar bot√µes conforme o estado
        if self.current_state == "initial":
            # Estado inicial: permitir sele√ß√£o de pastas, gerenciamento de arquivos e processamento 
            self.process_button.config(state=tk.NORMAL, style='Primary.TButton')  # Bot√£o inicial em destaque
            self.help_button.config(state=tk.NORMAL)
            
            # Habilitar bot√µes de gerenciamento de arquivos
            self.add_files_button.config(state=tk.NORMAL)
            self.add_dir_button.config(state=tk.NORMAL)
            self.clear_files_button.config(state=tk.NORMAL)
            self.remove_files_button.config(state=tk.NORMAL)
            
            # Habilitar bot√µes de configura√ß√£o
            self.input_select_button.config(state=tk.NORMAL)
            self.output_select_button.config(state=tk.NORMAL)
            self.templates_select_button.config(state=tk.NORMAL)
            
        elif self.current_state == "processing" or self.current_state == "exporting":
            # Estado de processamento: nenhum bot√£o habilitado
            self.help_button.config(state=tk.NORMAL)
            
        elif self.current_state == "processed":
            # Processamento conclu√≠do: exporta√ß√£o e visualiza√ß√£o habilitados
            self.export_button.config(state=tk.NORMAL, style='Primary.TButton')  # Destacar bot√£o de exporta√ß√£o
            self.view_db_button.config(state=tk.NORMAL)
            self.help_button.config(state=tk.NORMAL)
            
        elif self.current_state == "exported":
            # Exporta√ß√£o conclu√≠da: apenas visualiza√ß√£o permitida
            self.view_db_button.config(state=tk.NORMAL)
            self.view_output_button.config(state=tk.NORMAL)
            self.help_button.config(state=tk.NORMAL)
            
        # Atualizar a interface
        self.root.update_idletasks()
    
def main():
    """Fun√ß√£o principal"""
    # Configurar logging antes de inicializar a GUI
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file, encoding='utf-8'),
            logging.StreamHandler()  # Para debug no console
        ]
    )
    
    root = tk.Tk()
    # Configurar tema ttk (usar ttkthemes se estiver dispon√≠vel)
    try:
        from ttkthemes import ThemedStyle
        style = ThemedStyle(root)
        style.set_theme("clearlooks")  # ou outro tema dispon√≠vel
    except ImportError:
        style = ttk.Style()
        if sys.platform.startswith('win'):
            style.theme_use('vista')
        elif sys.platform.startswith('darwin'):
            style.theme_use('aqua')
        else:
            style.theme_use('clam')
    
    # Criar um estilo para bot√µes prim√°rios
    style.configure('Primary.TButton', font=('Helvetica', 10, 'bold'))
    
    # Instanciar a aplica√ß√£o
    app = EsocialMigrationGUI(root)
    
    # Iniciar o loop principal
    root.mainloop()


if __name__ == "__main__":
    main()
